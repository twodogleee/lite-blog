"""

初始化数据库相关配置及数据相关操作对象

"""

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from config import DB_PATH, LOG_LEVEL
from sqlalchemy.pool import QueuePool
import logging

# 通过logging将执行的sql打印在控制台上 并设置颜色为蓝色方便调试
logging.basicConfig(level=logging.INFO, format='\033[1;34m%(levelname)s:%(name)s >>> %(message)s \033[0m')
logging.getLogger('sqlalchemy.engine').setLevel(LOG_LEVEL)

# 创建一个引擎对象，连接到SQLite数据库
engine = create_engine(
    DB_PATH,
    # echo=True, 是否将sqlalchemy的日志打印出来,这儿使用了logging 则不需要
    connect_args={"check_same_thread": False},
    poolclass=QueuePool,
    pool_size=2,
    max_overflow=10,
    pool_timeout=30
)

# 创建连接池
# pool = QueuePool(
#     creator=engine.connect,
#     max_overflow=10,  # 连接池中最多可以创建的连接数
#     pool_size=2,  # 连接池中保持的连接数
# )

# 创建 SessionLocal 数据库会话对象
# 这儿使用了连接池 可以直接实例化SessionLocal来访问数据库 用完之后会被连接池回收
# 如: db = SessionLocal() 即可
SessionLocal = sessionmaker(
    autocommit=False,  # 自动提交
    autoflush=True,  # 自动刷新
    bind=engine
)

"""
这个地方我直接使用了 sqlalchemy的链接池来控制链接的频繁创建
并没有使用fastApi的依赖注入
我想的是所有的数据库操作抽离到了dao层,执行完操作返回再执行下一步的业务逻辑,讲道理能解决大部分的并发问题
fastApi属于多线程框架,如果在同一个线程中使用了 不同的数据库会话可能会造成查询结果错误
例如，如果在一个会话中修改了一个对象，但在另一个会话中查询了同一个对象，那么查询结果可能会不正确，因为它没有反映出先前的修改。这是因为每个会话都有自己的缓存，不同的会话之间无法共享缓存。
此外，如果在多个会话中同时执行操作，可能会导致并发问题，例如死锁和竞态条件。这是因为每个会话都有自己的事务，而事务之间的交互可能会导致并发问题。
最好使用相同的数据库会话对象来执行整个调用中的所有操作，以确保数据的一致性和正确性。如果需要在多个线程中执行操作，则可以使用线程本地存储来确保每个线程都使用自己的数据库会话对象。
比如fastApi中推荐操作:
# 定义依赖项函数
def get_db():
    try:
        db = SessionLocal()
        yield db
    finally:
        db.close()

# 在路由中使用依赖项函数
@app.get("/")
async def read_root(db = Depends(get_db)):
    # 在此处执行数据库操作
    # ...
    return {"message": "Hello World"}
在api层将数据库的会话对象通过依赖注入,然后在下层方法中用参数接受而达到使用同一个数据库会话对象,可以保证在同一个调用中不会出现不一样的结果

"""
"""
以下来自gpt的回答:
问:
fastApi在路由器便实例化了SessionLocal 这样做的意义或者目的是什么 
答:
在 FastAPI 中，使用 `SessionLocal` 实例化一个数据库会话对象的主要目的是为了在每个请求中使用一个单独的数据库会话对象，这有助于确保每个请求都有自己的数据库会话，避免在并发请求中出现数据混乱的情况。
具体来说，`SessionLocal` 是一个工厂函数，用于创建一个 SQLAlchemy 的 `Session` 对象。在 FastAPI 应用程序中，每当有一个请求到达时，路由器会实例化一个 `SessionLocal` 对象，然后将其作为参数传递给处理该请求的函数。这样，每个请求都将使用自己的 `Session` 对象，从而避免了多个请求共享同一个 `Session` 对象所带来的潜在问题。
此外，`SessionLocal` 还包含了一些配置，例如连接数据库的 URL、连接池大小等等。这些配置可以根据具体的应用程序需求进行调整，以获得最佳的性能和稳定性。
问:
那这个请求需要处理时间很长的话会不会一直占用这个数据库资源
答:
如果请求需要处理时间很长，那么它会一直占用这个数据库资源，这可能会导致其他请求等待时间过长或者超时。为了避免这种情况，可以考虑使用异步非阻塞的方式来处理请求。在 FastAPI 中，可以使用异步视图函数和异步数据库驱动程序来实现这一点。异步视图函数可以让请求处理过程中的 IO 操作（例如数据库查询）不会阻塞其他请求的处理。异步数据库驱动程序可以让数据库查询也不会阻塞其他请求的处理。这样，即使某个请求需要处理时间很长，也不会一直占用数据库资源，其他请求也能够正常处理。
问:
那系统复杂度是不是上去了
答:
是的，使用线程本地存储（TLS）确实会增加系统的复杂度，因为您需要确保每个线程都使用自己的数据库会话对象，并且您需要处理线程之间的同步和竞态条件。但是，这种方法可以确保您的应用程序在高并发情况下能够正常工作，并且不会出现数据库连接池的瓶颈问题。因此，如果您的应用程序需要处理大量的数据库操作，并且需要高并发性能，那么使用线程本地存储（TLS）可能是一个不错的选择。
问:
那是不是在执行数据库操作的时候再通过SessionLocal创建session对象更合理
答:
是的，您可以在需要执行数据库操作的时候使用 `SessionLocal()` 创建一个新的数据库会话对象。这种方法可以确保每个线程都使用自己的数据库会话对象，并且不需要使用线程本地存储（TLS）来存储会话对象。但是，这种方法可能会导致数据库连接池的瓶颈问题，因为每次创建新的会话对象都需要从连接池中获取新的数据库连接。因此，如果您的应用程序需要处理大量的数据库操作，并且需要高并发性能，那么使用线程本地存储（TLS）可能是一个更好的选择。
问:
在数据库操作时才创建session 对象是否也能规避多个请求共享同一个 Session 对象所带来的潜在问题。
答:
是的，当您在需要执行数据库操作时才创建 Session 对象时，可以避免多个请求共享同一个 Session 对象所带来的潜在问题。这是因为每个请求都会创建自己的 Session 对象，并且在请求处理完成后会自动关闭该对象，从而确保每个请求都使用自己的数据库会话对象。这种方法可以避免多个请求之间共享同一个 Session 对象所带来的并发问题，同时还可以减少数据库连接池的瓶颈问题。因此，在 FastAPI 应用程序中使用 SessionLocal() 创建 Session 对象是一个不错的选择。
问:
那是不是连接池加操作时再实例化session对象就可以完美解决你说的问题 
答:
是的，如果您使用连接池来管理数据库连接，那么在操作数据库时再实例化 Session 对象是一个很好的选择。这样可以确保每个请求都使用自己的 Session 对象，并且可以重复使用连接池中的数据库连接，从而提高应用程序的性能和并发能力。但是，请注意，如果您使用的是连接池，则需要确保在使用完 Session 对象后将其关闭，以释放数据库连接并将其返回到连接池中。如果您不关闭 Session 对象，则可能会出现连接泄漏的情况，从而导致应用程序性能下降或数据库崩溃。因此，在使用连接池时，请务必小心处理 Session 对象的生命周期。
问:
sqlalchemy的链接池不是自动回收吗,为什么我还需要手动关闭
答:
是的，SQLAlchemy 的连接池确实会自动回收空闲连接。但是，连接池并不会自动关闭数据库会话对象。如果您在使用 SQLAlchemy 时不手动关闭会话对象，会导致连接泄漏和资源浪费。因此，建议您在每个请求结束时手动关闭会话对象，以确保连接池中的连接能够被正确释放。如果您使用的是 Flask SQLAlchemy，可以在请求结束时使用 `teardown_request` 钩子函数来关闭会话对象。如果您使用的是其他框架或原生的 SQLAlchemy，可以在请求处理完成后手动关闭会话对象。
问:
如何手动关闭会话对象呢 
答:
在使用 SQLAlchemy 时，可以使用 `session.close()` 方法手动关闭会话对象。这将释放会话所占用的资源，并将其从会话工厂中移除。如果您使用的是上下文管理器 `with` 语句创建的会话对象，那么会话对象会在 `with` 语句结束时自动关闭，不需要手动调用 `close()` 方法。但是如果您手动创建了会话对象并执行了数据库操作，那么在操作完成后，最好手动关闭会话对象以释放资源。

"""
